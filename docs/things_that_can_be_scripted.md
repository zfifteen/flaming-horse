# Opportunities for More Deterministic Video Production

**Analysis Date:** 2026-02-13  
**Purpose:** Identify tasks currently performed by the AI agent that could be "put on rails" via bash/python scripts to reduce variability and errors in rendered videos.

---

## Executive Summary

After analyzing the current workflow, I identified **7 high-value scripting opportunities** that would reduce agent decision-making and increase determinism. The current system already does a good job with `build_video.sh` orchestration and validation, but there are several areas where the agent is still making decisions that could be codified into scripts.

---

## Current State Analysis

### What's Already Scripted (‚úÖ Good)
1. **Project scaffolding** (`new_project.sh`) - Creates `project_state.json` with correct structure
2. **State machine orchestration** (`build_video.sh`) - Phase transitions, locking, backups
3. **Validation gates** (`validate_scene_imports`, `validate_voiceover_sync`) - Import naming, hardcoded text detection
4. **Quality control** (`qc_final_video.sh`) - Audio/video duration checks, silence detection
5. **Phase reset** (`reset_phase.sh`) - Manual recovery

### What the Agent Still Decides (‚ö†Ô∏è Opportunities)
1. Scene file boilerplate generation
2. Voice config file creation
3. Narration script file structure
4. Timing budget calculations
5. `scenes.txt` file generation for ffmpeg
6. Pre-render validation (positioning, timing)
7. State file updates between phases

---

## High-Value Scripting Opportunities

### 1. Scene File Scaffolding Script üî• **HIGH PRIORITY**

**Current Agent Task:**  
The agent generates complete scene `.py` files from scratch, including 60+ lines of boilerplate (imports, compatibility patch, config, helpers, class structure).

**What Can Be Scripted:**  
A `scaffold_scene.py` script that generates the entire boilerplate and leaves only a `# TODO: Add animations here` placeholder.

```bash
# Proposed usage:
./scripts/scaffold_scene.py \
    --project projects/my_video \
    --scene-id scene_01_intro \
    --class-name Scene01Intro \
    --narration-key intro
```

**Script Output:** A valid `.py` file with:
- All imports (correct `manim_voiceover_plus` naming)
- Python 3.13 compatibility patch
- Locked config block
- `safe_position()` and `safe_layout()` helpers
- VoiceoverScene class with ElevenLabs setup
- A single `with self.voiceover(text=SCRIPT["intro"]) as tracker:` block ready for animations

**Why This Matters:**  
- Eliminates import naming mistakes (currently 10+ lines of validation in `build_video.sh`)
- Ensures consistency across all scenes
- Agent only needs to fill in the animation content

**Estimated Complexity:** Medium (template string substitution)

---

### 2. Voice Config Generator üî• **HIGH PRIORITY**

**Current Agent Task:**  
The agent creates `voice_config.py` during the narration phase, which must contain specific locked values.

**What Can Be Scripted:**  
The `voice_config.py` file is 100% deterministic‚Äîalways the same content. It should be generated by `new_project.sh` automatically.

```python
# scripts/generate_voice_config.py
# Or just add to new_project.sh:
cat > "$PROJECT_DIR/voice_config.py" <<'EOF'
"""
Voice configuration for ElevenLabs TTS
LOCKED - Do not modify
"""

from elevenlabs import VoiceSettings

VOICE_ID = "rBgRd5IfS6iqrGfuhlKR"
MODEL_ID = "eleven_multilingual_v2"

VOICE_SETTINGS = VoiceSettings(
    stability=0.5,
    similarity_boost=0.75,
    style=0.0,
    use_speaker_boost=True
)
EOF
```

**Why This Matters:**  
- Eliminates risk of wrong voice ID or model
- No agent decision required
- File is identical for every project

**Estimated Complexity:** Low (add 15 lines to `new_project.sh`)

---

### 3. Narration Script Scaffolding üìÑ **MEDIUM PRIORITY**

**Current Agent Task:**  
The agent creates `narration_script.py` with a `SCRIPT` dictionary containing keys matching `plan.json` scene IDs.

**What Can Be Scripted:**  
A script that reads `plan.json` and generates the `narration_script.py` skeleton with correct keys and placeholders.

```bash
# Proposed usage:
./scripts/scaffold_narration.py --project projects/my_video

# Reads plan.json, generates:
SCRIPT = {
    "intro": """# TODO: Write narration for 'What Are Gravity Anomalies?'
    # Target: ~75 words, ~30 seconds
    """,
    "bouguer_correction": """# TODO: Write narration for 'The Bouguer Correction'
    # Target: ~150 words, ~60 seconds
    """,
    ...
}
```

**Why This Matters:**  
- Keys always match `plan.json`
- Word count targets are embedded
- Agent only writes content, not structure

**Estimated Complexity:** Low (JSON parsing + template)

---

### 4. Timing Budget Validator üïê **HIGH PRIORITY**

**Current Agent Task:**  
The agent must manually calculate that timing fractions sum to ‚â§1.0 within each `voiceover` block. This is error-prone and causes animation/audio desync.

**What Can Be Scripted:**  
A Python linter that parses scene files and validates timing budgets.

```bash
# Proposed usage:
./scripts/validate_timing.py projects/my_video/scene_01_intro.py

# Output:
‚úÖ Scene01Intro: voiceover block 1 - timing total: 0.4 + 0.3 + 0.3 = 1.0 ‚úì
‚ùå Scene01Intro: voiceover block 2 - timing total: 0.6 + 0.5 = 1.1 > 1.0 OVERFLOW
   Line 45: run_time=tracker.duration * 0.6
   Line 48: run_time=tracker.duration * 0.5
```

**Implementation:**  
Use Python's `ast` module to parse the scene file and extract `tracker.duration * X` patterns, then sum them per voiceover block.

**Why This Matters:**  
- Prevents the most common cause of "dead air" in videos
- Can be added to `build_video.sh` as a gate before `final_render`
- Catches errors before expensive ElevenLabs API calls

**Estimated Complexity:** Medium (AST parsing)

---

### 5. scenes.txt Generator üìù **LOW PRIORITY (but easy)**

**Current Agent Task:**  
During `assemble` phase, the agent creates `scenes.txt` with file paths for ffmpeg concatenation.

**What Can Be Scripted:**  
100% deterministic‚Äîread `project_state.json` and generate the file.

```bash
# scripts/generate_scenes_txt.sh
PROJECT_DIR="$1"
STATE_FILE="${PROJECT_DIR}/project_state.json"

python3 <<EOF
import json
with open('${STATE_FILE}') as f:
    state = json.load(f)
with open('${PROJECT_DIR}/scenes.txt', 'w') as out:
    for scene in state['scenes']:
        out.write(f"file '{scene['video_file']}'\n")
EOF
```

**Why This Matters:**  
- Agent doesn't need to touch this
- Could be built into `build_video.sh` at the start of `assemble` phase

**Estimated Complexity:** Very Low

---

### 6. Pre-Render Positioning Validator üìê **MEDIUM PRIORITY**

**Current Agent Task:**  
The agent is responsible for following positioning rules (use `UP * 3.8` not `.to_edge(UP)`, call `safe_position()` after `.next_to()`, etc.).

**What Can Be Scripted:**  
A linter that scans scene files for known anti-patterns.

```bash
# Proposed usage:
./scripts/lint_positioning.py projects/my_video/scene_01_intro.py

# Output:
‚ö†Ô∏è  Line 42: .to_edge(UP) detected - use .move_to(UP * 3.8) for titles
‚ö†Ô∏è  Line 56: .next_to() without safe_position() call
‚ùå  Line 63: Multiple elements at ORIGIN without offsets
```

**Patterns to Detect:**
- `.to_edge(UP)` ‚Üí suggest `.move_to(UP * 3.8)`
- `.next_to(...)` not followed by `safe_position()`
- Multiple `.move_to(ORIGIN)` calls without offsets
- Missing `safe_layout()` for VGroups with siblings

**Why This Matters:**  
- Prevents top-of-frame clipping (a real issue mentioned in docs)
- Catches overlap issues before rendering
- Complements existing `validate_voiceover_sync` check

**Estimated Complexity:** Medium (regex + AST analysis)

---

### 7. State Machine Advancement Script üîÑ **LOW PRIORITY**

**Current Agent Task:**  
The agent updates `project_state.json` to advance phases, update scene status, and log history entries.

**What Can Be Scripted:**  
State transition helpers that the agent calls instead of writing JSON directly.

```bash
# scripts/advance_phase.py
./scripts/advance_phase.py projects/my_video plan review

# scripts/mark_scene_built.py  
./scripts/mark_scene_built.py projects/my_video scene_01_intro

# scripts/mark_scene_rendered.py
./scripts/mark_scene_rendered.py projects/my_video scene_01_intro \
    --video-path media/videos/.../Scene01Intro.mp4
```

**Why This Matters:**  
- Reduces JSON manipulation errors
- Ensures consistent history logging
- Agent just calls command, doesn't write JSON

**Estimated Complexity:** Low (JSON manipulation)

---

## Recommended Implementation Order

| Priority | Script | Effort | Impact |
|----------|--------|--------|--------|
| 1 | Voice Config Generator | Low | High (eliminates voice ID errors) |
| 2 | Scene File Scaffolding | Medium | High (60+ lines of boilerplate per scene) |
| 3 | Timing Budget Validator | Medium | High (prevents audio desync) |
| 4 | Narration Script Scaffolding | Low | Medium (structure correctness) |
| 5 | scenes.txt Generator | Very Low | Low (but trivial to implement) |
| 6 | Pre-Render Positioning Validator | Medium | Medium (prevents clipping) |
| 7 | State Machine Advancement | Low | Low (convenience) |

---

## What Should Remain Agent Tasks

Some tasks are inherently creative and should NOT be scripted:

1. **Plan generation** (`plan.json`) - Requires understanding the topic and breaking it into scenes
2. **Narration writing** - The actual prose content
3. **Animation design** - The creative visualization choices
4. **Review phase judgments** - Feasibility assessment requires reasoning

The goal is to give the agent **less boilerplate to write** and **more guardrails to operate within**, not to replace its creative function.

---

## Implementation Notes

### Adding New Validators to build_video.sh

New validation scripts should follow this pattern:

```bash
# In handle_build_scenes()
if ! ./scripts/validate_timing.py "$scene_file"; then
    echo "‚úó Timing validation failed" | tee -a "$LOG_FILE"
    # Log error to state, return 1
fi
```

### Script Location

All new scripts should go in `/scripts/` directory and be executable:

```bash
chmod +x scripts/scaffold_scene.py
chmod +x scripts/validate_timing.py
```

### Testing New Scripts

Before integrating, test against existing projects:

```bash
./scripts/validate_timing.py projects/parametric_resonance/scene_01_threshold_intro.py
./scripts/lint_positioning.py projects/parametric_resonance/scene_02_resonance_mechanism.py
```

---

## Conclusion

The current system is well-architected with good separation between orchestration (`build_video.sh`) and creative work (agent). The opportunities identified here focus on:

1. **Eliminating boilerplate** - Scene scaffolding, voice config
2. **Catching errors earlier** - Timing validation, positioning linting
3. **Removing trivial decisions** - scenes.txt generation, state updates

Implementing priorities 1-3 would likely eliminate the most common failure modes with minimal development effort.
