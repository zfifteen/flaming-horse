import ast
import hashlib
import json
import subprocess
from pathlib import Path
from typing import Dict, Optional

from manim_voiceover_plus.defaults import DEFAULT_VOICEOVER_CACHE_DIR
from manim_voiceover_plus.services.base import SpeechService


class MLXCachedService(SpeechService):
    MLX_PYTHON = "/Users/velocityworks/qwen3-tts-local/mlx_env312/bin/python"
    SERVICE_SCRIPT = str(Path(__file__).with_name("mlx_tts_service.py"))
    DEFAULT_MODEL_ID = "mlx-community/Qwen3-TTS-12Hz-0.6B-Base-4bit"
    REF_AUDIO = "/Users/velocityworks/qwen3-tts-local/voice_ref/ref.wav"
    REF_TEXT_FILE = REF_AUDIO.replace(".wav", ".txt")

    @staticmethod
    def _load_script(script_path: Path) -> Dict[str, str]:
        try:
            tree = ast.parse(
                script_path.read_text(encoding="utf-8"), filename=str(script_path)
            )
        except (OSError, SyntaxError, ValueError):
            return {}
        for node in tree.body:
            if not isinstance(node, ast.Assign):
                continue
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id == "SCRIPT":
                    try:
                        value = ast.literal_eval(node.value)
                    except (ValueError, TypeError):
                        return {}
                    return value if isinstance(value, dict) else {}
        return {}

    def __init__(
        self,
        project_dir,
        cache_dir,
        cache_index,
        text_index,
        transcription_model=None,
        **kwargs,
    ):
        self.project_dir = project_dir
        self.cache_index = cache_index
        self.text_index = text_index
        super().__init__(
            cache_dir=str(cache_dir), transcription_model=transcription_model, **kwargs
        )

    @classmethod
    def from_project(cls, project_dir):
        project_dir = Path(project_dir).resolve()
        cache_dir = project_dir / "media" / DEFAULT_VOICEOVER_CACHE_DIR / "mlx"
        config_path = project_dir / "voice_clone_config.json"
        if config_path.exists():
            try:
                config = json.loads(config_path.read_text(encoding="utf-8"))
                output_dir = config.get("output_dir")
                if output_dir:
                    output_path = Path(output_dir).expanduser()
                    cache_dir = (
                        output_path
                        if output_path.is_absolute()
                        else project_dir / output_dir
                    )
            except (json.JSONDecodeError, OSError):
                pass
        cache_file = cache_dir / "cache.json"
        cache_index = {}
        text_index = {}
        if cache_file.exists():
            for entry in json.loads(cache_file.read_text(encoding="utf-8")):
                key = entry.get("narration_key")
                audio_file = entry.get("audio_file")
                text = entry.get("text")
                if key and audio_file:
                    cache_index[key] = audio_file
                if text and audio_file:
                    normalized = " ".join(str(text).split())
                    text_index[normalized] = audio_file
        else:
            script_path = project_dir / "narration_script.py"
            if script_path.exists():
                for key, text in cls._load_script(script_path).items():
                    audio_file = f"{key}.mp3"
                    if (cache_dir / audio_file).exists():
                        cache_index[key] = audio_file
                        normalized = " ".join(str(text).split())
                        text_index[normalized] = audio_file

        return cls(
            project_dir=project_dir,
            cache_dir=cache_dir,
            cache_index=cache_index,
            text_index=text_index,
        )

    def _narration_key(self, input_data):
        return input_data.get("narration_key")

    def _generate_audio(self, text: str, narration_key: Optional[str] = None) -> Path:
        """Generate audio via MLX service subprocess."""
        segments = [{"id": narration_key or "seg", "text": text}]
        segments_json = json.dumps(segments)
        cmd = [
            self.MLX_PYTHON,
            self.SERVICE_SCRIPT,
            segments_json,
            self.DEFAULT_MODEL_ID,
        ]
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=300, cwd=self.project_dir
        )
        if result.returncode != 0:
            raise RuntimeError(f"MLX service failed: {result.stderr}")
        lines = [ln.strip() for ln in result.stdout.splitlines() if ln.strip()]
        payload = lines[-1] if lines else ""
        paths_data = json.loads(payload)
        if not paths_data:
            raise RuntimeError("No audio generated by MLX service")
        out_path = Path(paths_data[0]["path"])
        if not out_path.is_absolute():
            out_path = self.project_dir / out_path
        return out_path

    def _update_cache(self, narration_key: str, audio_file: str, text: str):
        """Update cache.json with new entry."""
        cache_file = Path(self.cache_dir) / "cache.json"
        entries = []
        if cache_file.exists():
            entries = json.loads(cache_file.read_text(encoding="utf-8"))
        entry = {
            "narration_key": narration_key,
            "audio_file": audio_file,
            "text": text,
        }
        entries.append(entry)
        cache_file.write_text(
            json.dumps(entries, indent=2, ensure_ascii=False), encoding="utf-8"
        )

    def _convert_to_mp3(self, src_path: Path, dest_path: Path) -> None:
        dest_path.parent.mkdir(parents=True, exist_ok=True)
        subprocess.run(
            [
                "ffmpeg",
                "-y",
                "-loglevel",
                "error",
                "-i",
                str(src_path),
                str(dest_path),
            ],
            check=True,
        )

    def generate_from_text(
        self, text: str, cache_dir: Optional[str] = None, path: Optional[str] = None
    ) -> dict:
        input_data = {"input_text": text}

        narration_key = None
        if path:
            narration_key = Path(path).stem
        if narration_key is None:
            narration_key = self._narration_key(input_data)
        audio_file = None
        if narration_key:
            audio_file = self.cache_index.get(narration_key)
        if not audio_file:
            normalized = " ".join(text.split())
            audio_file = self.text_index.get(normalized)

        if not audio_file:
            # Generate new
            print(f"Generating new audio for key '{narration_key or 'normalized'}'")
            wav_path = self._generate_audio(text, narration_key)
            audio_file = f"{wav_path.stem}.mp3"
            cache_mp3 = Path(self.cache_dir) / audio_file
            self._convert_to_mp3(wav_path, cache_mp3)
            if wav_path.exists():
                wav_path.unlink()
            # Update indices
            if narration_key:
                self.cache_index[narration_key] = audio_file
            normalized = " ".join(text.split())
            self.text_index[normalized] = audio_file
            # Update cache.json
            self._update_cache(narration_key or "normalized", audio_file, text)
            print(f"Cached new audio: {cache_mp3}")

        cache_dir_path = Path(self.cache_dir)
        audio_path = cache_dir_path / audio_file

        if audio_path.suffix.lower() != ".mp3":
            converted = audio_path.with_suffix(".mp3")
            self._convert_to_mp3(audio_path, converted)
            audio_file = converted.name
            audio_path = converted
            if narration_key:
                self.cache_index[narration_key] = audio_file
            normalized = " ".join(text.split())
            self.text_index[normalized] = audio_file
            self._update_cache(narration_key or "normalized", audio_file, text)

        if not audio_path.exists():
            raise FileNotFoundError(f"Cached audio file not found: {audio_path}")

        # Create stable hash
        data_hash = hashlib.sha256(text.encode("utf-8")).hexdigest()[:8]
        return {
            "input_text": text,
            "input_data": {
                "input_text": text,
                "service": "mlx_cached",
                "config": {
                    "cache_dir": str(cache_dir_path),
                },
                "narration_key": narration_key,
            },
            "original_audio": audio_file,
            "final_audio": audio_file,
            "data_hash": data_hash,
            "cached": audio_file in self.cache_index or audio_file in self.text_index,
        }
