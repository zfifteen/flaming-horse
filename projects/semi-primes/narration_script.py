"""
Narration script for: semi-primes
Generated: 2026-02-14
Duration: ~300 seconds
"""

SCRIPT = {
    "intro": """Imagine a number so simple to multiply but impossibly hard to factor—that's the magic of semi-primes powering RSA encryption, securing your online banking and messages. A prime number can only be divided by 1 and itself: 2, 3, 5, 7, 11. A semi-prime is the product of exactly two primes, like 4 equals 2 times 2, 6 is 2 times 3, 15 is 3 times 5, or 35 is 5 times 7. Today, we'll explore what makes these numbers special and why factoring large ones is a cryptographic holy grail.""",
    "examples": """Semi-primes come in all sizes and varieties. Small ones like 9—3 squared—or 25, 5 squared, are easy to spot. Larger ones like 143, which is 11 times 13, or 221, 13 times 17, show their pattern. Even semi-primes? Only 4, from 2 times 2. All others are odd. They're dense among composites: about 35% of numbers below 100 are semi-prime. But as numbers grow, factoring gets exponentially harder, which is why cryptographers love 2048-bit semi-primes—their factors are hundreds of digits long.""",
    "trial_division": """The simplest way to factor a semi-prime? Trial division: check divisibility by primes up to its square root. Take 143. Start with 2—no. 3: 1+4+3=8, not divisible by 3. 5—no. 7: 143 divided by 7 is 20.428, no. 11: 143 over 11 is 13 exactly! Found it. Optimize by checking only odds after 2 and up to sqrt(143) about 12. So stop at 11. But for a 600-digit semi-prime? You'd need trillions of trillions of trials—impossible on classical computers. Time complexity is O(sqrt(N)), brutal for crypto sizes.""",
    "advanced": """Smarter algorithms exist. Pollard's rho uses a pseudo-random sequence to find factors via birthday paradox collisions—fast for semi-primes up to 100 digits. Fermat's method shines when factors are close: if N = p*q and p ≈ q, then N + k^2 might be a difference of squares. Quadratic sieve builds a factor base and solves linear equations over GF(2) for smooth numbers—world record classical factoring is 829 bits. But all hit walls at RSA sizes; they need heroic computation.""",
    "rsa": """RSA encryption weaponizes semi-prime hardness. Choose two large primes p and q, compute N = p times q—your public modulus. Public key is (N, e), private is (N, d) where d inverts e modulo (p-1)(q-1). Encrypt: C = M^e mod N. Decrypt: M = C^d mod N. Anyone can encrypt with public key, but without factors, computing d from e is as hard as factoring N. A 2048-bit N takes billions of years to factor today, but seconds to multiply—perfect asymmetry for secure communication worldwide.""",
    "recap": """To wrap up: semi-primes are products of two primes, easy to make, hard to break—trial division works small-scale, advanced methods like rho and quadratic sieve push limits, but RSA relies on their factoring resistance at huge scales. Quantum computers threaten with Shor's algorithm, but classical security holds for now. Next time you use HTTPS, thank semi-primes. Explore factoring challenges yourself—start small, dream big. Thanks for watching!""",
}
