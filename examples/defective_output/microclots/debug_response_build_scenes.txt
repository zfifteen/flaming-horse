from manim import *
import numpy as np
import colorsys

# ── Voiceover Imports ──────────────────────────────────────────────
from pathlib import Path
from manim_voiceover_plus import VoiceoverScene
from flaming_horse_voice import get_speech_service

# ============================================================================
# OPTIMIZED CONFIGURATION - DO NOT MODIFY THESE VALUES
# ============================================================================
config.frame_height = 10
config.frame_width = 10 * 16/9  # 17.78
config.pixel_height = 1440
config.pixel_width = 2560
# ============================================================================


# ── Safe Positioning Helpers ───────────────────────────────────────
def safe_position(mobject, max_y=3.8, min_y=-3.8, buff=0.2):
    """
    Clamp mobject to safe vertical zone to prevent clipping.

    Args:
        mobject: The Manim mobject to check and adjust
        max_y: Maximum safe y-coordinate (default 3.8)
        min_y: Minimum safe y-coordinate (default -3.8)

    Returns:
        The adjusted mobject (for chaining)
    """
    top = mobject.get_top()[1]
    bottom = mobject.get_bottom()[1]

    if top > max_y - buff:
        mobject.shift(DOWN * (top - (max_y - buff)))
    if bottom < min_y + buff:
        mobject.shift(UP * ((min_y + buff) - bottom))

    return mobject


def safe_layout(*mobjects, min_horizontal_spacing=0.5, max_y=3.8, min_y=-3.8):
    """
    Ensure multiple mobjects don't overlap and stay within safe bounds.

    Args:
        *mobjects: Variable number of mobjects to validate
        min_horizontal_spacing: Minimum x-axis gap between elements (default 0.5)
        max_y: Maximum safe y-coordinate (default 3.8)
        min_y: Minimum safe y-coordinate (default -3.8)

    Returns:
        List of adjusted mobjects
    """
    # Apply vertical bounds to all elements
    for mob in mobjects:
        top = mob.get_top()[1]
        bottom = mob.get_bottom()[1]
        if top > max_y:
            mob.shift(DOWN * (top - max_y))
        elif bottom < min_y:
            mob.shift(UP * (min_y - bottom))

    # Check horizontal overlap between all pairs
    for i, mob_a in enumerate(mobjects):
        for mob_b in mobjects[i+1:]:
            a_left = mob_a.get_left()[0]
            a_right = mob_a.get_right()[0]
            b_left = mob_b.get_left()[0]
            b_right = mob_b.get_right()[0]

            # If bounding boxes overlap on x-axis
            if not (a_right < b_left or b_right < a_left):
                overlap = (a_right - b_left) if a_right > b_left else (b_right - a_left)
                mob_b.shift(RIGHT * (overlap + min_horizontal_spacing))

    return list(mobjects)


# ── Visual Helpers ────────────────────────────────────────────────
def harmonious_color(base_color, variations=3, lightness_shift=0.1):
    """Generate cohesive color variants from a base color."""
    rgb = np.array(base_color.to_rgb())
    h, l, s = colorsys.rgb_to_hls(*rgb)
    palette = []
    for i in range(variations):
        h_shift = i * (360 / variations) / 360
        new_h = (h + h_shift) % 1
        new_l = min(1.0, max(0.0, l + lightness_shift * i))
        new_r, new_g, new_b = colorsys.hls_to_rgb(new_h, new_l, s)
        palette.append([new_r, new_g, new_b, 1.0])
    return palette


def polished_fade_in(mobject, lag_ratio=0.2, scale_factor=1.1, glow=False):
    """Smooth reveal with optional glow and a quick scale pop."""
    if glow:
        mobject.set_stroke(width=3, opacity=0.5)
    return LaggedStart(
        FadeIn(mobject),
        mobject.animate.scale(scale_factor).set_run_time(0.5).scale(1 / scale_factor),
        lag_ratio=lag_ratio,
    )


def adaptive_title_position(title, content_group, max_shift=0.5):
    """Shift title up slightly when content is tall."""
    content_height = content_group.height if content_group else 0
    shift_y = min(max_shift, max(0, content_height - 2.0))
    title.move_to(UP * (3.8 + shift_y))
    return title


# ── Timing Helpers ────────────────────────────────────────────────
class BeatPlan:
    """Allocates deterministic timing slots across a voiceover block."""

    def __init__(self, total_duration, weights):
        self.total_duration = max(0.0, float(total_duration))
        cleaned = [max(0.0, float(w)) for w in weights]
        if not cleaned:
            raise ValueError("BeatPlan requires at least one weight")
        weight_sum = sum(cleaned)
        if weight_sum <= 0:
            cleaned = [1.0 for _ in cleaned]
            weight_sum = float(len(cleaned))

        slots = []
        consumed = 0.0
        for idx, weight in enumerate(cleaned):
            if idx == len(cleaned) - 1:
                slot = max(0.0, self.total_duration - consumed)
            else:
                slot = self.total_duration * (weight / weight_sum)
                consumed += slot
            slots.append(slot)
        self._slots = slots
        self._cursor = 0

    def next_slot(self):
        if self._cursor >= len(self._slots):
            return 0.0
        slot = self._slots[self._cursor]
        self._cursor += 1
        return slot


def play_in_slot(scene, slot, *animations, max_run_time=None, min_run_time=0.3, **play_kwargs):
    """Play one beat slot and fill unused time with wait."""
    if not animations:
        return

    if "run_time" in play_kwargs:
        raise ValueError("Do not pass run_time to play_next/play_text_next; timing must come from BeatPlan slots.")

    slot = max(0.0, float(slot))
    if slot <= 0:
        return

    animation = animations[0] if len(animations) == 1 else LaggedStart(*animations, lag_ratio=0.15)

    run_time = slot
    if max_run_time is not None:
        run_time = min(run_time, float(max_run_time))
    run_time = max(float(min_run_time), run_time)
    run_time = min(run_time, slot)

    scene.play(animation, run_time=run_time, **play_kwargs)
    remaining = slot - run_time
    if remaining > 1e-6:
        scene.wait(remaining)


def play_text_in_slot(scene, slot, *animations, max_text_seconds=1.5, min_run_time=0.3, **play_kwargs):
    """Text should never take longer than 1.5 seconds to display."""
    return play_in_slot(
        scene,
        slot,
        *animations,
        max_run_time=max_text_seconds,
        min_run_time=min_run_time,
        **play_kwargs,
    )


def play_next(scene, beats, *animations, max_run_time=None, min_run_time=0.3, **play_kwargs):
    return play_in_slot(
        scene,
        beats.next_slot(),
        *animations,
        max_run_time=max_run_time,
        min_run_time=min_run_time,
        **play_kwargs,
    )


def play_text_next(scene, beats, *animations, max_text_seconds=1.5, min_run_time=0.3, **play_kwargs):
    return play_text_in_slot(
        scene,
        beats.next_slot(),
        *animations,
        max_text_seconds=max_text_seconds,
        min_run_time=min_run_time,
        **play_kwargs,
    )


# ── Narration Script ───────────────────────────────────────────────
# Import from shared narration_script.py or define here
SCRIPT = {
    "scene_07_conclusion": """In summary, long COVID microclots are more than stubborn clots—they're dynamical traps of fibrin and NETs in a self-reinforcing dance. The key to breaking free is sequential NET-degrading therapy, timing DNase before fibrinolytics. That said, this is based on in vitro simulations, so clinical validation is essential. Remember, in these traps, timing isn't just important—it's everything."""
}


class Scene07Conclusion(VoiceoverScene):
    """
    Conclusion and Scope scene: Wrap up with the broader implications and limitations of this model.
    """

    def construct(self):
        # ── Configure cached Qwen TTS ───────────────────────────────
        self.set_speech_service(get_speech_service(Path(__file__).resolve().parent))

        # ── Title + Main Content (single voiceover block) ─────────
        with self.voiceover(text=SCRIPT["scene_07_conclusion"]) as tracker:
            # Duration-scaled beat density (root-cause fix for sparse scenes)
            num_beats = max(12, min(30, int(np.ceil(tracker.duration / 1.8))))
            beats = BeatPlan(tracker.duration, [1] * num_beats)

            # Title (ALWAYS use UP * 3.8, NEVER .to_edge(UP))
            greens = harmonious_color(GREEN, variations=3)
            title = Text("Conclusion and Scope", font_size=48, weight=BOLD, color=greens[0])
            title.move_to(UP * 3.8)
            play_text_next(self, beats, Write(title))

            subtitle = Text("Broader Implications and Limitations", font_size=32, color=greens[1])
            subtitle.next_to(title, DOWN, buff=0.4)
            safe_position(subtitle)
            play_text_next(self, beats, polished_fade_in(subtitle, lag_ratio=0.1))

            # Progressive bullets (left panel)
            bullet_1 = Text("Dynamical trap insight", font_size=28, color=greens[2]).move_to(LEFT * 4.8 + UP * 1.6)
            bullet_2 = Text("Sequential therapy key", font_size=28).next_to(bullet_1, DOWN, aligned_edge=LEFT, buff=0.3)
            safe_position(bullet_2)
            bullet_3 = Text("Limitations: In vitro model", font_size=28).next_to(bullet_2, DOWN, aligned_edge=LEFT, buff=0.3)
            safe_position(bullet_3)
            bullet_4 = Text("Timing is critical", font_size=28).next_to(bullet_3, DOWN, aligned_edge=LEFT, buff=0.3)
            safe_position(bullet_4)

            # Evolving right-panel visual: recap diagram of the trap cycle
            panel = RoundedRectangle(width=5.2, height=3.2, corner_radius=0.2, color=TEAL).move_to(RIGHT * 3.2 + DOWN * 0.6)
            fibrin_node = Dot(panel.get_center() + LEFT * 1.2, color=RED)
            fibrin_label = Text("Fibrin", font_size=20, color=RED)
            fibrin_label.next_to(fibrin_node, UP, buff=0.2)
            safe_position(fibrin_label)
            nets_node = Dot(panel.get_center() + RIGHT * 1.2, color=BLUE)
            nets_label = Text("NETs", font_size=20, color=BLUE)
            nets_label.next_to(nets_node, UP, buff=0.2)
            safe_position(nets_label)
            cycle_arrow = CurvedArrow(fibrin_node.get_center(), nets_node.get_center(), color=YELLOW)
            reverse_arrow = CurvedArrow(nets_node.get_center(), fibrin_node.get_center(), color=YELLOW)

            # 'Break the Trap' callout
            callout = Text("Break the Trap", font_size=24, weight=BOLD, color=YELLOW)
            callout.next_to(panel, UP, buff=0.3)
            safe_position(callout)

            # Future research icon: question mark
            research_icon = Text("?", font_size=36, color=GOLD).next_to(panel, DOWN, buff=0.3)
            safe_position(research_icon)

            play_text_next(self, beats, FadeIn(bullet_1))
            play_text_next(self, beats, FadeIn(bullet_2))
            play_text_next(self, beats, FadeIn(bullet_3))
            play_text_next(self, beats, FadeIn(bullet_4))

            # Cleanup before visuals
            play_next(self, beats, FadeOut(subtitle), FadeOut(bullet_1), FadeOut(bullet_2), FadeOut(bullet_3), FadeOut(bullet_4))
            play_next(self, beats, Create(panel, rate_func=smooth))
            play_next(self, beats, FadeIn(fibrin_node), FadeIn(fibrin_label))
            play_next(self, beats, FadeIn(nets_node), FadeIn(nets_label))
            play_next(self, beats, FadeIn(cycle_arrow), FadeIn(reverse_arrow))
            play_next(self, beats, FadeIn(callout))
            play_next(self, beats, FadeIn(research_icon))

            # Final cleanup
            play_next(self, beats, FadeOut(title), FadeOut(panel), FadeOut(fibrin_node), FadeOut(fibrin_label), FadeOut(nets_node), FadeOut(nets_label), FadeOut(cycle_arrow), FadeOut(reverse_arrow), FadeOut(callout), FadeOut(research_icon))